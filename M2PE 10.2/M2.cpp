extern "C" {#include <machine/machine_routines.h>}#include <IOKit/pwr_mgt/RootDomain.h>#include <IOKit/IODeviceTreeSupport.h>#include <IOKit/IORangeAllocator.h>#include <IOKit/nvram/IONVRAMController.h>#include "../OpenPMU/OpenPMU.h"#include "M2.h"#define VERBOSE 1#define ALLOW_SLEEP 0#if VERBOSE    #define VerboseIOLog(x...) IOLog(x)#else    #define VerboseIOLog(x...) {}#endif#define super ApplePlatformExpertOSDefineMetaClassAndStructors(M2PE, ApplePlatformExpert);bool M2PE::start(IOService *provider){	IOReturn superRet;        	setBootROMType(kBootROMTypeOldWorld);	setChipSetType(kChipSetTypeM2);	_pePMFeatures =	kPMHasWakeupTimerMask |					kPMHasProcessorCyclingMask |					kPMHasSCSIDiskModeMask |					kPMCanGetBatteryTimeMask |					kPMHasStartupTimerMask |					kPMHasChargeNotificationMask |					kPMHasSleepMask;	_pePrivPMFeatures = kStdPowerBookPrivPMFeatures;	_peNumBatteriesSupported = 1;		superRet = super::start(provider);        	return superRet;}void M2PE::registerNVRAMController(IONVRAMController *nvram){	UInt32 timeToGMT = 0;	IOReturn err;		enum {kXPRAMTimeToGMTOffset = 0xEC};	super::registerNVRAMController(nvram);	err = readXPRAM(kXPRAMTimeToGMTOffset, (UInt8 *) &timeToGMT, sizeof(timeToGMT));		VerboseIOLog("M2PE: readXPRAM returned %x, timeToGMT = %x\n", err, (unsigned int) timeToGMT);}	IOReturn M2PE::callPlatformFunction(const OSSymbol *functionName,					  bool waitForFunction,					  void *param1, void *param2,					  void *param3, void *param4){	VerboseIOLog("M2PE::callPlatformFunction entered, functionName = %s\n", functionName->getCStringNoCopy());        	if (functionName->isEqualTo("GetDefaultBusSpeeds")) {		getDefaultBusSpeeds((long *) param1, (unsigned long **) param2);		return kIOReturnSuccess;	}  	return super::callPlatformFunction(functionName, waitForFunction,				     param1, param2, param3, param4);                                     	VerboseIOLog("M2PE::callPlatformFunction exited\n");}static unsigned long m2Speed[] = {33333333, 1};void M2PE::getDefaultBusSpeeds(long *numSpeeds, unsigned long **speedList){	if (!numSpeeds || !speedList)		return;	    *numSpeeds = 1;    *speedList = m2Speed;}void M2PE::PMInstantiatePowerDomains (void){	root = new IOPMrootDomain;	root->init();	root->attach(this);	root->start(this);	root->youAreRoot();#if ALLOW_SLEEP   	root->setSleepSupported(kRootDomainSleepSupported);#else	root->setSleepSupported(kRootDomainSleepNotSupported);#endif}void M2PE::PMRegisterDevice(IOService *theNub, IOService *theDevice){	mach_timespec_t t;	IOService *baboon;			//    VerboseIOLog("M2PE::PMRegisterDevice entered; theNub is %s, theDevice is %s\n", theNub->getName(), theDevice->getName());    // Checks if the nub handles power states, if it does not gets its parent and so    // up until we reach the root, or we do not find anything:    while ((theNub != NULL) && ( theNub->addPowerChild(theDevice) != IOPMNoErr )) {		// Attempt to attach services descending from the ATA nodes to the Baboon driver		if (!strcmp(theNub->getName(), "ata")) {			t.tv_sec = 60;			t.tv_nsec = 0;			baboon = waitForService(serviceMatching("Baboon"), &t);			if (baboon) {				theNub = baboon;				continue;			}		}				theNub = theNub->getProvider();	}    if ( theNub == NULL ) {        root->addPowerChild ( theDevice );        return;    }}#if 1void M2PE::PMLog(const char * who,unsigned long event,unsigned long param1, unsigned long param2){//    if( gIOKitDebug & kIOLogPower) {//        kprintf("%s %02d %08x %08x\n",who,event,param1,param2);        IOLog("%s %02d %08x %08x\n",who,event,param1,param2);//    }}#endif